import requests
import json
from concurrent.futures import ThreadPoolExecutor
import concurrent.futures

# Replace with your GitLab instance URL and personal access token
GITLAB_URL = "https://gitlab.example.com"
ACCESS_TOKEN = "your_personal_access_token"
OUTPUT_FILE = "repositories_packages.json"

HEADERS = {
    "Private-Token": ACCESS_TOKEN
}

def get_all_projects():
    projects = []
    page = 1
    while True:
        response = requests.get(f"{GITLAB_URL}/api/v4/projects", headers=HEADERS, params={"page": page, "per_page": 100})
        if response.status_code != 200:
            raise Exception(f"Failed to retrieve projects: {response.status_code} {response.text}")
        
        data = response.json()
        if not data:
            break
        
        projects.extend(data)
        page += 1
    
    return projects

def get_file_content(project_id, file_path, ref="master"):
    url = f"{GITLAB_URL}/api/v4/projects/{project_id}/repository/files/{file_path}/raw"
    response = requests.get(url, headers=HEADERS, params={"ref": ref})
    if response.status_code == 200:
        return response.text
    return None

# Parsers for various package manager files
def parse_package_json(content):
    packages = []
    try:
        data = json.loads(content)
        dependencies = data.get("dependencies", {})
        dev_dependencies = data.get("devDependencies", {})
        for package, version in {**dependencies, **dev_dependencies}.items():
            packages.append({"name": package, "version": version})
    except json.JSONDecodeError:
        pass
    return packages

def parse_requirements_txt(content):
    packages = []
    lines = content.splitlines()
    for line in lines:
        if "==" in line:
            package, version = line.split("==")
            packages.append({"name": package.strip(), "version": version.strip()})
        else:
            packages.append({"name": line.strip(), "version": None})
    return packages

def parse_composer_json(content):
    packages = []
    try:
        data = json.loads(content)
        dependencies = data.get("require", {})
        dev_dependencies = data.get("require-dev", {})
        for package, version in {**dependencies, **dev_dependencies}.items():
            packages.append({"name": package, "version": version})
    except json.JSONDecodeError:
        pass
    return packages

def parse_gemfile(content):
    packages = []
    lines = content.splitlines()
    for line in lines:
        if line.startswith("gem"):
            parts = line.split(",")
            package = parts[0].split()[1].strip("'")
            version = parts[1].strip().strip("'") if len(parts) > 1 else None
            packages.append({"name": package, "version": version})
    return packages

def parse_pom_xml(content):
    from xml.etree import ElementTree as ET
    packages = []
    try:
        root = ET.fromstring(content)
        for dependency in root.findall(".//dependency"):
            group_id = dependency.find("groupId").text
            artifact_id = dependency.find("artifactId").text
            version = dependency.find("version").text if dependency.find("version") is not None else None
            packages.append({"name": f"{group_id}:{artifact_id}", "version": version})
    except ET.ParseError:
        pass
    return packages

def parse_build_gradle(content):
    packages = []
    lines = content.splitlines()
    for line in lines:
        if line.strip().startswith("implementation") or line.strip().startswith("compile"):
            parts = line.split("'")
            if len(parts) == 3:
                package = parts[1]
                packages.append({"name": package, "version": None})
    return packages

def parse_packages_config(content):
    from xml.etree import ElementTree as ET
    packages = []
    try:
        root = ET.fromstring(content)
        for package in root.findall(".//package"):
            name = package.get("id")
            version = package.get("version")
            packages.append({"name": name, "version": version})
    except ET.ParseError:
        pass
    return packages

def parse_cargo_toml(content):
    packages = []
    lines = content.splitlines()
    for line in lines:
        if "=" in line:
            package, version = line.split("=")
            packages.append({"name": package.strip(), "version": version.strip().strip('"')})
    return packages

def parse_go_mod(content):
    packages = []
    lines = content.splitlines()
    for line in lines:
        if "require" in line:
            parts = line.split()
            if len(parts) == 3:
                package = parts[1]
                version = parts[2]
                packages.append({"name": package, "version": version})
    return packages

def parse_mix_exs(content):
    packages = []
    lines = content.splitlines()
    for line in lines:
        if line.strip().startswith("{:"):
            parts = line.split(",")
            package = parts[0].split()[1].strip(":")
            version = parts[1].strip().strip("}")
            packages.append({"name": package, "version": version})
    return packages

def fetch_and_parse_files(project):
    project_id = project['id']
    project_name = project['name']
    project_info = {
        "project_id": project_id,
        "project_name": project_name,
        "web_url": project['web_url'],
        "description": project.get('description'),
        "packages": []
    }

    files_to_check = [
        {"file": "package.json", "parser": parse_package_json},
        {"file": "requirements.txt", "parser": parse_requirements_txt},
        {"file": "composer.json", "parser": parse_composer_json},
        {"file": "Gemfile", "parser": parse_gemfile},
        {"file": "pom.xml", "parser": parse_pom_xml},
        {"file": "build.gradle", "parser": parse_build_gradle},
        {"file": "packages.config", "parser": parse_packages_config},
        {"file": "Cargo.toml", "parser": parse_cargo_toml},
        {"file": "go.mod", "parser": parse_go_mod},
        {"file": "mix.exs", "parser": parse_mix_exs}
    ]

    for file in files_to_check:
        content = get_file_content(project_id, file["file"])
        if content:
            packages = file["parser"](content)
            for pkg in packages:
                pkg["file"] = file["file"]
                project_info["packages"].append(pkg)

    return project_info

def main():
    projects = get_all_projects()
    all_project_data = []

    with ThreadPoolExecutor(max_workers=10) as executor:
        future_to_project = {executor.submit(fetch_and_parse_files, project): project for project in projects}
        for future in concurrent.futures.as_completed(future_to_project):
            project_data = future.result()
            all_project_data.append(project_data)

    with open(OUTPUT_FILE, "w") as f:
        json.dump(all_project_data, f, indent=4)
    
    print(f"Data has been written to {OUTPUT_FILE}")

if __name__ == "__main__":
    main()
